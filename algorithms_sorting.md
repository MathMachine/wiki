## Сортировка

Под *временной сложностью алгоритма* понимают функцию $T(n)$ от размерности входных данных $n$, равную наибольшему времени работы алгоритма на входных данных размерности $n$.
Размерность входных данных -- это мера их количества, она может быть задана несколькими числами.

Эффективность алгоритма зависит от того, как быстро растет $T(n)$ с ростом $n$. Основным показателем временной сложности алгоритма служит асимптотическая скорость увеличения времени работы алгоритма при $n \to \infty$. Например, если временная сложность -- это полином $T(n) = an^p + bn^{p-1} + cn + d$, то при больших $n$ слагаемое со старшей степенью $n^p$ будет значительно больше, чем все другие слагаемые, и поэтому порядок скорости роста $T(n)$ характеризует эффективность алгоритма при больших $n$.

Говорят, что $T(n)$ -- бесконечно большая функция менее высокого порядка, чем $f(n)$, если $T(n) \leq Cf(n)$, начиная с некоторого $n = n_0$. В этом случае пишут $T(n) = O(f(n))$, подразумевая под $O(f(n))$ класс функций, а равенство в этой формуле обозначает принадлежность функции этому классу.

Задача сортировки заключается в переупорядочении последовательности ключей $a_1, a_2, \ldots, a_n$ (к которой привязаны блоки данных)
так, чтобы $a_1' \leq a_2' \leq \ldots \leq a_n'$.

Если процедура сортировки опирается только на операцию сравнения двух значений ключей, в результате которой можно сказать, что одно ключевое
значение меньше другого, то временная сложность имеет порядок роста не лучше, чем $O(n\log n)$.
Можно нарисовать двоичное дерево, в котором узлы будут соответствовать некоторым упорядочениям данных после определенного количества
сделанных сравнений ключей. 
В каждом узле, кроме листьев, программа определяет порядок данных посредством сравнения каких-либо двух элементов, например:
"является ли $k_1 < k_2$?". В зависимости от возможных ответов на этот вопрос создаются два сына этого узла. Левый сын соответствует
случаю, когда значения ключей удовлетворяют неравенству $k_1 < k_2$; правый сын соответствует упорядочению при выполнении неравенства $k_1 > k_2$.

Поскольку всего возможных порядков следования элементов $n!$, то в этом дереве всего $n!$ листьев. Высота дерева равна $\log_2(n!)$, так что
время выполнения алгоритма сортировки оценивается сверху величиной $O(\log(n!)) = O(n\log n)$.

### Сортировка вставками, сортировка выбором, пузырьковая сортировка

### Сортировка слиянием

Рекурсивные алгоритмы разбивают большую задачу на несколько подзадач. При 
рекурсивном подходе сортируемые элементы разбиваются на две группы, каждая из этих 
меньших групп сортируется рекурсивно, после чего два отсортированных списка 
сливаются воедино, и их элементы чередуются, образуя полностью отсортированный 
общий список. Этот алгоритм называется сортировкой слиянием (mergesort). 

```
Mergesort(A[1,n]) 
Merge( MergeSort(A[1, [n/2]), Mergesort(A[[n/2] + 1,n]) ) 
```

Базовый случай рекурсивной сортировки имеет место, когда исходный массив состоит 
из одного элемента, вследствие чего перестановки в нем невозможны. На рисунке 
показана графическая иллюстрация работы алгориГма сортировки слиянием; Сортировку 
слиянием можно представлять себе как симметричный обход верхнего дерева, при 
котором преобразования представлены в нижнем (перевернутом) дереве. 

![Рис. 1](/images/algorithms/sorting/mergesort.png)

Заметим, что подпрограмма сортировки дважды вызывает саму себя с глубиной рекурсии порядка $\log_2 n$.
Суммарное количество сравнений на каждой глубине рекурсии равно $O(n)$. Таким образом, сортировка слиянием
потребует порядка $O(n\log n)$ операций.

Алгоритм сортировки слиянием хорошо подходит для сортировки связных списков, 
т. к. он, в отличие от алгоритмов пирамидальной и быстрой сортировки, не 
основывается на произвольном доступе к элементам. Его основным недостатком является 
необходимость во вспомогательном буфере при сортировке массивов. Отсортированные 
связные списки можно легко слить вместе, не требуя дополнительной памяти, а просто 
упорядочивая указатели. Но для влияния двух отсортированных массивов (или частей 
массива) требуется третий массив для хранения результатов слияния, чтобы не потет 
рять содержимое сливаемых массивов. Допустим, что мы сливаем множества {4, 5, 6} 
и {1,2, 3}., записанные слева направо в одном массиве. Без использования буфера нам 
придется записывать отсортированные элементы поверх элементов первой половины 
массива, вследствие чего последние будут утеряны.
 
Сортировка слиянием является классическим примером алгоритмов типа "разделяй и 
властвуй". Мы всегда в выигрыше, когда можем разбить одну большую задачу на две 
подзадачи, т. к. меньшие задачи легче решить. Секрет заключается в том, чтобы 
воспользоваться двумя частичными решениями для создания решения всей задачи, как это 
было сделано с операцией слияния. 


### Быстрая сортировка



### Литература

[Федоряева] [Федоряева -- Комбинаторные алгоритмы (2011)](https://disk.yandex.ru/i/DBgC07alC4gp9g)

[Скиена] [Скиена -- Алгоритмы. Руководство по разработке (2011)](https://disk.yandex.ru/i/OXMuS4pgrm5MBQ)

[КЛРШ] [Кормен, Лейзерсон, Ривест, Штайн -- Алгоритмы: Построение и анализ (2013)](https://disk.yandex.ru/i/3y3lloOX_yz3rA)

[Ахо] [Ахо, Хопкрофт, Ульман -- Структуры данных и алгоритмы (2000)](https://yadi.sk/i/S0l1uKNKi7r1Pg) -- С. 254-257

[ИТМО] [Онлайн-курс от Университета ИТМО на платформе Открытое образование](https://openedu.ru/course/ITMOUniversity/PADS/)
