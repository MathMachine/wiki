## Алгоритмы сортировки

### Сортировка выбором

#### Источники

1. [Khan Academy - Selection sort](https://www.khanacademy.org/computing/computer-science/algorithms/sorting-algorithms/a/sorting)



### Сортировка вставками

#### Источники

1. [Khan Academy - Insertion sort](https://www.khanacademy.org/computing/computer-science/algorithms/insertion-sort/a/insertion-sort)



### Сортировка слиянием

#### Источники

1. [Khan Academy - Merge sort](https://www.khanacademy.org/computing/computer-science/algorithms/merge-sort/a/divide-and-conquer-algorithms)

### Быстрая сортировка

Дополнительная информация:
- [Обозначение $\Theta$](https://www.khanacademy.org/computing/computer-science/algorithms/asymptotic-notation/a/big-big-theta-notation)
- [Обозначение $O$](https://www.khanacademy.org/computing/computer-science/algorithms/asymptotic-notation/a/big-o-notation)


#### Общее представление

Так же как и сортировка слиянием, быстрая сортировка использует метод ["разделяй и властвуй"](https://www.khanacademy.org/computing/computer-science/algorithms/merge-sort/a/divide-and-conquer-algorithms), поэтому это рекурсивный алгоритм.
Метод "разделяй и властвуй" в быстрой сортировке применяется несколько иначе, чем в сортировке слиянием.
В сортировке слиянием на этапе *разделения* не выполняется почти никаких действий, и вся основная работа происходит на этапе *соединения*. Напротив, в быстрой сортировке вся основная работа выполняется на этапе *разделения*. Фактически на этапе *соединения* в быстрой сортировке ничего не происходит.

У быстрой сортировки есть и другие отличия от сортировки слиянием. Быстрая сортировка тут же сортирует массив.
И время ее выполнения *в худшем случае* имеет такую же асимптотику, как и сортировка выбором и сортировка вставками: $\Theta(n^2)$.
Но ее время выполнения *в среднем* асимптотически эквивалентно времени выполнения сортировки слиянием: $\Theta(n\log_2 n)$.
Итак, почему стоит рассмотреть быструю сортировку, если сортировка слиянием по крайней мере не хуже?
Дело в том, что постоянный множитель, спрятанный в обозначении $\Theta$, имеет достаточно неплохое значение у быстрой сортировки. На практике быстрая сортировка превосходит сортировку слиянием и существенно превосходит сортировку выбором и сортировку вставками.

Рассмотрим, как быстрая сортировка использует метод "разделяй и властвуй". Как и в случае сортировки слиянием, рассмотрим задачу сортировки подмассива `array[p..r]`, а изначальный подмассив -- это `array[0..n-1]`.

1. **Разделение.** Выберем любой элемент в подмассиве `array[p..r]`. Назовем этот элемент **опорным**.
Переставим элементы в подмассиве `array[p..r]` таким образом, чтобы все элементы в `array[p..r]`, которые *меньше либо равны* опорному элементу, находились *слева от него*, а все элементы, которые *больше* опорного элемента, находились *справа от него*. Эту процедуру мы будем называть **разбиением**. На этом этапе нам неважно, в каком порядке идут элементы, находящиеся слева от опорного элемента, и в каком порядке идут элементы, находящиеся справа от него.
Нам важно только то, что каждый элемент находится с нужной стороны от опорного элемента.
<br>
На практике мы будем всегда выбирать в качестве *опорного элемента* самый правый элемент подмассива -- `array[r]`.
Например, если подмассив -- [9, 7, 5, 11, 12, 2, 14, 3, 10, 6], то опорным элементом будет 6. После *разбиения* подмассив может выглядеть следующим образом: [5, 2, 3, 6, 12, 7, 14, 9, 10, 11]. Пусть `q` -- индекс опорного элемента.

2. **Властвование.** Рекурсивно отсортируем подмассивы `array[p..q-1]` (все элементы слева от опорного элемента, которые должны быть *меньше либо равны* опорному элементу)
и `array[q+1..r]` (все элементы справа от опорного элемента, которые должны быть *больше* опорного элемента).

3. **Соединение.** Ничего не нужно делать. После рекурсивных вызовов подмассив отсортирован. Почему? Все элементы слева от опорного элемента, `array[p..q-1]`, меньше либо равны опорному элементу и отсортированы (согласно предположению индукции), а все элементы справа от опорного элемента, `array[q+1..r]`, больше, чем опорный элемент, и тоже отсортированы. Поэтому элементы всего подмассива `array[p..r]` просто не могут быть не отсортированы!

Рассмотрим наш пример. После рекурсивного вызова сортировки подмассивов слева и справа от опорного элемента подмассив слева от опорного элемента будет [2, 3, 5], подмассив справа от опорного элемента будет [7, 9, 10, 11, 12, 14].
Поэтому весь подмассив -- это [2, 3, 5], за которым идет опорный элемент 6, после чего идут [7, 9, 10, 11, 12, 14]. Подмассив отсортирован.

Базовые случаи -- это когда в подмассивах меньше двух элементов, как это было в сортировке слиянием. В сортировке слиянием у нас никогда не было подмассива без элементов, но такая ситуация возможна в быстрой сортировке, если все остальные элементы подмассива меньше опорного элемента или все они больше опорного элемента.

Вернемся к этапу *властвования* и разберем рекурсивную сортировку подмассивов. После первого разбиения у нас есть подмассивы [5, 2, 3] и [12, 7, 14, 9, 10, 11], а 6 -- опорный элемент.

Чтобы отсортировать подмассив [5, 2, 3], мы выберем 3 в качестве опорного элемента. После *разбиения* получим [2, 3, 5]. Подмассив [2] слева от опорного элемента относится к базовому случаю при очередном рекурсивном вызове, как и подмассив [5] справа от опорного элемента.

Чтобы отсортировать подмассив [12, 7, 14, 9, 10, 11], выберем 11 в качестве опорного элемента, тогда получим [7, 9, 10] слева от опорного элемента и [14, 12] справа от него.
После того, как эти подмассивы будут отсортированы, мы получим [7, 9, 10], дальше 11 и [12, 14].

На рисунке показана работа всего алгоритма быстрой сортировки. Элементы массива, выделенные голубым цветом, были опорными элементами на предшествующих рекурсивных вызовах, и поэтому эти элементы в дальнейшем не рассматриваются и не перемещаются.

![Рис. 1](/images/algorithms/sorting/quicksort/1.png)


#### Разбиение за линейное время

Основная работа быстрой сортировки происходит на этапе *разделения*, который разбивает подмассив `array[p..r]` относительно *опорного элемента*, выбранного из этого подмассива. Хотя мы можем выбрать любой элемент подмассива в качестве опорного, легко реализовать разбиение, если выбрать опорным *самый правый* элемент подмассива -- `A[r]`.

После выбора опорного элемента алгоритм разбивает подмассив, проходя по нему слева направо и сравнивая каждый элемент с опорным. Хранятся два индекса `q` и `j` элементов подмассива, которые разделяют его на 4 группы. Мы используем имя переменной `q`, потому что этот индекс в конце концов укажет на наш опорный элемент. Мы используем имя `j`, потому что это имя часто используется для счетчика, и после выполнения процедуры разбиения эта переменная нам будет не нужна.

* Элементы подмассива `array[p..q-1]` -- это *"группа L"*, которая состоит из элементов, про которых известно, что они меньше (*l*ess) либо равны опорному элементу.
* Элементы подмассива `array[q..j-1]` -- это *"группа G"*, которая состоит из элементов, про которых известно, что они больше (*g*reater), чем опорный элемент.
* Элементы подмассива `array[j..r-1]` -- это *"группа U"*, которая состоит из элементов, про которых неизвестно (*u*nknown), как они соотносятся с опорным элементом, потому что они с ним еще не сравнивались.
* Наконец, `array[r]` -- это *"группа P"* -- опорный элемент (*p*ivot).

Сначала оба индекса `q` и `j` равны `p`.
На каждом шаге мы сравниваем `A[j]`, самый левый элемент в группе U, с опорным элементом. Если `A[j]` больше опорного элемента, то мы просто увеличиваем `j` на 1, и тогда
линия между группами G и U сдвинется на один элемент вправо:

![Рис. 2](/images/algorithms/sorting/quicksort/2.png)


Если же `A[j]` меньше либо равно опорному элементу, то мы меняем местами `A[j]` с `A[q]` (самым левым элементом в группе G), увеличиваем `j` на 1, тем самым линия между группами L и G, как и линия между группами G и U, сдвигаются на один элемент вправо:

![Рис. 3](/images/algorithms/sorting/quicksort/3.png)


Когда мы дойдем до опорного элемента, группа U будет пустой. Остается поменять местами опорный элемент с самым левым элементом группы G: поменять местами `A[r]` и `A[q]`. Этот обмен помещает опорный элемент между группами L и G, и это правильный шаг, даже если группа L или группа G является пустой. (Если группа L пуста, то это значит, что `q` ни разу не увеличивалось и оставалось равным начальному значению `p`, поэтому опорный элемент становится на самое левое место в подмассиве. Если группа G пуста, то это означает, что `q` увеличивалось на единицу каждый раз, когда `j` увеличивалось на единицу, и поэтому, когда `j` достигло индекса опорного элемента `r`, то `q` = `r`, и обмен местами `A[r]` и `A[q]` оставляет опорный элемент на самом правом месте в подмассиве.)
Функция `partition`, которая реализует эту идею, также возвращает индекс `q`, на котором оказался опорный элемент, поэтому функция `quicksort`, которая вызывает эту функцию, будет знать, где находится линия раздела между двумя частями подмассива.
На рисунке показаны шаги разбиения подмассива [12, 7, 14, 9, 10, 11], который содержится в `array[4..9]`:

![Рис. 4](/images/algorithms/sorting/quicksort/4.png)


Разбиение подмассива из $n$ элементов займет $\Theta(n)$ времени. Каждый элемент `A[j]` сравнивается с опорным элементом ровно один раз. `A[j]` может обмениваться или не обмениваться местами с `A[q]`, `q` может увеличиваться на 1 или не увеличиваться на 1, и `j` всегда увеличивается на 1. Общее число действий, выполненных для каждого элемента подмассива, -- величина постоянная. Так как в подмассиве $n$ элементов, то время разбиения есть $\Theta(n)$: разбиение производится за линейное время.


#### Источники

1. [Khan Academy - Quick sort](https://www.khanacademy.org/computing/computer-science/algorithms/quick-sort/a/overview-of-quicksort)
2. [Бхаргава А. Грокаем алгоритмы -- С. 85-98](https://yadi.sk/i/YXiwk6VPxKf5Zg)
3. [Визуализация алгоритма](http://algo-visualizer.jasonpark.me/#path=sorting/quick/basic)
4. Algomation - визуализация: [1](http://www.algomation.com/player?algorithm=58bb2ef75b2b830400b05118), [2](http://www.algomation.com/player?algorithm=545ec1b758d3ab0200e12085), [3](http://www.algomation.com/player?algorithm=58b44c720e406f04000c713b)

### Источники

1. [Алгоритмы сортировки в танце](https://forany.xyz/a-370)
2. [Сложность алгоритмов сортировки](http://bigocheatsheet.com)
