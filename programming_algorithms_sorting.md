## Алгоритмы сортировки

### Сортировка выбором

#### Источники

1. [Khan Academy - Selection sort](https://www.khanacademy.org/computing/computer-science/algorithms/sorting-algorithms/a/sorting)



### Сортировка вставками

#### Источники

1. [Khan Academy - Insertion sort](https://www.khanacademy.org/computing/computer-science/algorithms/insertion-sort/a/insertion-sort)



### Сортировка слиянием

#### Источники

1. [Khan Academy - Merge sort](https://www.khanacademy.org/computing/computer-science/algorithms/merge-sort/a/divide-and-conquer-algorithms)

### Быстрая сортировка

Дополнительная информация:
- [Обозначение $\Theta$](https://www.khanacademy.org/computing/computer-science/algorithms/asymptotic-notation/a/big-big-theta-notation)
- [Обозначение $O$](https://www.khanacademy.org/computing/computer-science/algorithms/asymptotic-notation/a/big-o-notation)

Так же как и сортировка слиянием, быстрая сортировка использует метод ["разделяй и властвуй"](https://www.khanacademy.org/computing/computer-science/algorithms/merge-sort/a/divide-and-conquer-algorithms), поэтому это рекурсивный алгоритм.
Метод "разделяй и властвуй" в быстрой сортировке применяется несколько иначе, чем в сортировке слиянием.
В сортировке слиянием на этапе *разделения* не выполняется почти никаких действий, и вся основная работа происходит на этапе *соединения*. Напротив, в быстрой сортировке вся основная работа выполняется на этапе *разделения*. Фактически на этапе *соединения* в быстрой сортировке ничего не происходит.

У быстрой сортировки есть и другие отличия от сортировки слиянием. Быстрая сортировка тут же сортирует массив.
И время ее выполнения *в худшем случае* имеет такую же асимптотику, как и сортировка выбором и сортировка вставками: $\Theta(n^2)$.
Но ее время выполнения *в среднем* асимптотически эквивалентно времени выполнения сортировки слиянием: $\Theta(n\log_2 n)$.
Итак, почему стоит рассмотреть быструю сортировку, если сортировка слиянием по крайней мере не хуже?
Дело в том, что постоянный множитель, спрятанный в обозначении $\Theta$, имеет достаточно неплохое значение у быстрой сортировки. На практике быстрая сортировка превосходит сортировку слиянием и существенно превосходит сортировку выбором и сортировку вставками.

Рассмотрим, как быстрая сортировка использует метод "разделяй и властвуй". Как и в случае сортировки слиянием, рассмотрим задачу сортировки подмассива `array[p..r]`, а изначальный подмассив -- это `array[0..n-1]`.

1. **Разделение.** Выберем любой элемент в подмассиве `array[p..r]`. Назовем этот элемент **опорным**.
Переставим элементы в подмассиве `array[p..r]` таким образом, чтобы все элементы в `array[p..r]`, которые *меньше либо равны* опорному элементу, находились *слева от него*, а все элементы, которые *больше* опорного элемента, находились *справа от него*. Эту процедуру мы будем называть **разбиением**. На этом этапе нам неважно, в каком порядке идут элементы, находящиеся слева от опорного элемента, и в каком порядке идут элементы, находящиеся справа от него.
Нам важно только то, что каждый элемент находится с нужной стороны от опорного элемента.
<br>
На практике мы будем всегда выбирать в качестве *опорного элемента* самый правый элемент подмассива -- `array[r]`.
Например, если подмассив -- [9, 7, 5, 11, 12, 2, 14, 3, 10, 6], то опорным элементом будет 6. После *разбиения* подмассив может выглядеть следующим образом: [5, 2, 3, 6, 12, 7, 14, 9, 10, 11]. Пусть `q` -- индекс опорного элемента.

2. **Властвование.** Рекурсивно отсортируем подмассивы `array[p..q-1]` (все элементы слева от опорного элемента, которые должны быть *меньше либо равны* опорному элементу)
и `array[q+1..r]` (все элементы справа от опорного элемента, которые должны быть *больше* опорного элемента).

3. **Соединение.** Ничего не нужно делать. После рекурсивных вызовов подмассив отсортирован. Почему? Все элементы слева от опорного элемента, `array[p..q-1]`, меньше либо равны опорному элементу и отсортированы (согласно предположению индукции), а все элементы справа от опорного элемента, `array[q+1..r]`, больше, чем опорный элемент, и тоже отсортированы. Поэтому элементы всего подмассива `array[p..r]` просто не могут быть не отсортированы!

Рассмотрим наш пример. После рекурсивного вызова сортировки подмассивов слева и справа от опорного элемента подмассив слева от опорного элемента будет [2, 3, 5], подмассив справа от опорного элемента будет [7, 9, 10, 11, 12, 14].
Поэтому весь подмассив -- это [2, 3, 5], за которым идет опорный элемент 6, после чего идут [7, 9, 10, 11, 12, 14]. Подмассив отсортирован.

Базовые случаи -- это когда в подмассивах меньше двух элементов, как это было в сортировке слиянием. В сортировке слиянием у нас никогда не было подмассива без элементов, но такая ситуация возможна в быстрой сортировке, если все остальные элементы подмассива меньше опорного элемента или все они больше опорного элемента.

Вернемся к этапу *властвования* и разберем рекурсивную сортировку подмассивов. После первого разбиения у нас есть подмассивы [5, 2, 3] и [12, 7, 14, 9, 10, 11], а 6 -- опорный элемент.

Чтобы отсортировать подмассив [5, 2, 3], мы выберем 3 в качестве опорного элемента. После *разбиения* получим [2, 3, 5]. Подмассив [2] слева от опорного элемента относится к базовому случаю при очередном рекурсивном вызове, как и подмассив [5] справа от опорного элемента.

Чтобы отсортировать подмассив [12, 7, 14, 9, 10, 11], выберем 11 в качестве опорного элемента, тогда получим [7, 9, 10] слева от опорного элемента и [14, 12] справа от него.
После того, как эти подмассивы будут отсортированы, мы получим [7, 9, 10], дальше 11 и [12, 14].

На рисунке показана работа всего алгоритма быстрой сортировки. Элементы массива, выделенные голубым цветом, были опорными элементами на предшествующих рекурсивных вызовах, и поэтому эти элементы в дальнейшем не рассматриваются и не перемещаются.

![Рис. 1](/images/algorithms/sorting/quicksort/1.png)


#### Источники

1. [Khan Academy - Quick sort](https://www.khanacademy.org/computing/computer-science/algorithms/quick-sort/a/overview-of-quicksort)
2. [Бхаргава А. Грокаем алгоритмы -- С. 85-98](https://yadi.sk/i/YXiwk6VPxKf5Zg)
3. [Визуализация алгоритма](http://algo-visualizer.jasonpark.me/#path=sorting/quick/basic)
4. Algomation - визуализация: [1](http://www.algomation.com/player?algorithm=58bb2ef75b2b830400b05118), [2](http://www.algomation.com/player?algorithm=545ec1b758d3ab0200e12085), [3](http://www.algomation.com/player?algorithm=58b44c720e406f04000c713b)

### Источники

1. [Алгоритмы сортировки в танце](https://forany.xyz/a-370)
2. [Сложность алгоритмов сортировки](http://bigocheatsheet.com)
