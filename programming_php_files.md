## PHP для начинающих: работа с файлами


Если язык JavaScript применяется для написания программ, которые выполняются на компьютере пользователя, который открывает тот или иной сайт, то язык PHP используется при написании программ, выполняемых непосредственно на удаленном компьютере — сервере.

Разберём важные (но не самые начальные) вопросы, связанные с PHP, — это работа с файлами. Зачем это нужно? Некоторые сайты, к которым вы обращаетесь, не требуют постоянного хранения определенной информации. Например, вы вводите арифметическое выражение, а сайт-калькулятор (точнее, программа, выполняемая на сервере) вычисляет его значение[^1]. Такому сайту не нужно ничего записывать в файл или считывать из файла. Но если, например, понадобится хранить историю выражений, которые вводят разные пользователи, то нам уже не обойтись без записи информации в файл или базу данных.

Обычно на практике информация хранится в базе данных. Тем не менее, некоторую информацию можно хранить и в файлах. Кстати, работать с файлами в PHP заметно легче, чем с базой данных. Работа с файлами PHP аналогична работе с файлами в других языках программирования: Паскаль, C++ и т.д. Вообще язык PHP больше похож на C++.

[^1]: Скрипт, написанный на JavaScript, загружается на клиентский компьютер пользователя и выполняется на нём, а скрипт, написанный на PHP, выполняется на сервере, и он даже не загружается на компьютер пользователя. Программу-калькулятор можно написать и на JavaScript, и на PHP.


### Установка веб-сервера

Чтобы вы могли работать с любым языком программирования, вам нужно иметь компилятор или интерпретатор — программу, которая выполнит вашу программу. В случае PHP вам понадобится установить на компьютер локальный веб-сервер. Удобнее всего использовать пакет Денвер — «Джентельменский набор веб-разработчика», который можно скачать с сайта http://www.denwer.ru. Просто следуйте инструкциям установщика, там все просто. Кстати, Денвер можно установить прямо на флешку и запускать все ваши сайты на любом компьютере.

Итак, предположим, что вы уже установили Денвер и можете открыть на своем компьютере сайт http://test1.ru, который находится в папке /home/test1.ru/www. Скорее всего, в этой папке есть файл index.html. Файлы, содержащие PHP-скрипты, имеют расширение .php. Поэтому создайте файл index.php со следующим содержимым:
```php
<?
echo "Привет, медведь!";
?>
```

Чтобы при обращении к сайту test1.ru открылся именно файл index.php, а не index.html, вам может понадобиться удалить или переименовать файл index.html. Откройте сайт test1.ru, и вы увидите на веб-странице сообщение «Привет, медведь!».

Все PHP-скрипты заключаются в операторные теги ```<? … ?>```

Там, где нет скобок (между PHP-вставками), может располагаться любой HTML-код. Если скобок и, соответственно, PHP-скриптов вообще нет, то файл с расширением .php воспринимается браузером так же, как и обычная веб-страница.

Функция ```echo``` выводит на экран текстовое сообщение. Аргумент функции необходимо заключить в кавычки. В PHP можно использовать как двойные, так и одинарные кавычки (апострофы), а аргумент функции echo можно заключить в скобки. Например:
```php
<?
  echo('Привет, медведь!<br>');
  echo('Привет, помидор!');
?>
```

Если пропустить точку с запятой после первого оператора, то вместо сообщения «Привет» появится пламенный привет от интерпретатора PHP — сообщение об ошибке.
Отметим, что текст, выводимый функцией `echo`, — это фактически HTML-код. Поэтому если не написать `<br>`, то оба сообщения окажутся на одной строке.



### Сайт-тестер

Начнем мы, пожалуй, с распространенной задачи, знакомой вам не понаслышке (вы ведь сдавали ЕГЭ) — это тестирование пользователя (например, студента). Вот пример подобного сайта, написанного на PHP: http://vlprog.besaba.com/test.

На странице будут перечислены вопросы, в каждом из которых один правильный вариант ответа. При нажатии на кнопку «Отправить» будет открываться другая страница, на которой будут показаны результаты тестирования.

Давайте начнем с простого. Напишем веб-страницу, на которой будет располагаться один тест с несколькими вариантами ответа и кнопка «Отправить». При нажатии на эту кнопку откроется другая страница (выданная PHP-скриптом), на которой будет показано, какой вариант ответа был выбран. Как видите, все очень просто.

Для реализации первой страницы нам с вами даже не нужен PHP, поскольку содержимое (HTML-код) этой страницы известно заранее, и его не требуется генерировать в зависимости от каких-то действий пользователя или еще чего-то (например, политической ситуации в мире). Поэтому файл с первой страницей назовем start.html. Файл со второй страницей назовем start.php.

Вот как будет выглядеть страница start.html.

![Рис. 1](/images/php/files/php_fig1.png)

А вот и HTML-код этой страницы.

```html
<html>
<head>
  <title>Проба пера</title>
</head>
<body>
  <form action="start.php" method="get">
    <p><b>Как, по вашему мнению, расшифровывается аббревиатура "ОС"?</b></p>
    <input type="radio" name="answer" value="1"/>Офицерский состав <br>
    <input type="radio" name="answer" value="2"/>Операционная система <br>
    <input type="radio" name="answer" value="3"/>Большой полосатый мух
    <p><input type="submit" value="Отправить"/></p>
  </form>
</body>
</html>
```

Уточнить информацию о HTML-тегах вы можете в интернет-источниках, например, http://htmlbook.ru.

Тег `<form>` задает форму — набор элементов веб-страницы, содержащих информацию, которая может быть отправлена на сервер в виде запроса. Атрибут `action` задает веб-страницу (в нашем случае с PHP-скриптом), которой будет передан данный запрос (которая будет обрабатывать данные, переданные на сервер). Атрибут `method` задает метод запроса. Если `method=get`, то значения параметров формы окажутся в адресной строке. Например, http://test1.ru/start.php?answer=3. Если `method=post`, то значения параметров формы пересылаются отдельно в запросе браузера, и в адресной строке это не проявляется.

Тег `<input>` может задавать как кнопку, так и текстовое поле или переключатель для выбора варианта ответа. Все зависит от значения атрибута input. Так, если ```input=radio```, то это переключатель, а если ```input=submit```, то это кнопка типа «Отправить», то есть при нажатии на такую кнопку происходит отправка данных на сервер, и открывается страница, указанная в атрибуте ```action``` тега ```form```. Атрибут name задает имя параметра, а атрибут ```value``` задает значение параметра.

Давайте теперь напишем PHP-скрипт для страницы start.php. На этой странице необходимо вывести тот вариант ответа, который был выбран.

После нажатия на кнопку «Отправить» откроется страница вида http://test1.ru/start.php?answer=3. Таким образом, нам нужно как-то получить доступ к переданной информации, то есть к значению параметра answer. Для этого в PHP есть массив `$_GET`.

Все переменные в PHP начинаются со знака доллара (`$`), за которым может следовать любое количество буквенно-цифровых символов и символов подчеркивания, но первый символ не может быть цифрой. Объявлять переменные, как, например, в Паскале или C++, не нужно. Массивы в PHP, как и в других языках программирования, — это набор элементов с общим именем, а к отдельным элементам можно обращаться по индексу. В PHP индексом элемента массива может быть не только число, но и строка. Отметим, что с каждым элементом массива можно работать точно так же, как и с обычной переменной. Таким образом, чтобы узнать значение параметра answer, достаточно обратиться к элементу `$_GET["answer"]`.

Давайте напишем в файле start.php код следующего содержания:
```php
<?
  echo $_GET["answer"];
?>
```

Теперь откройте страницу http://test1.ru/start.html и выберите какой-нибудь вариант ответа, например, «Большой полосатый мух». Вуаля! После нажатия на кнопку «Отправить» открылась страница http://test1.ru/start.php?answer=3, на которой написано число 3. Это значение параметра answer, указанное в поле `<input>`, соответствующее варианту «Большой полосатый мух». Если выбрать 1-й вариант ответа, то на страницу start.php будет выведено число 1.

Теперь нам, конечно же, хочется, чтобы выводился не номер варианта ответа, а сам вариант ответа. Рассмотрим пару способов сделать это.

Первый способ — использовать условный оператор `if`. Этот оператор выглядит следующим образом:
```php
<?
  $x = 2;
  if ($x == 1)
    echo "один";
  else
    echo "не один";
?>
```

Если при выполнении условия нужно выполнить несколько операторов, то используйте составной оператор — заключите несколько операторов в фигурные скобки.

```php
<?
  $x = 1;
  if ($x == 1) {
    echo "один<br>";
    echo "Эх, совсем один!";
  }
  else
    echo "не один";
?>
```

Если вам нужно сравнить два значения, то используйте два символа равно (`==`), а если вы хотите присвоить переменной какое-то значение, то используйте один символ равно (`=`). То есть операция присваивания в PHP записывается, как и в C++, в виде `=`, а операция сравнения — тоже как в C++, в виде `==`.

Чтобы вывести вариант ответа, используйте следующий код:

```php
<?
  $ans = $_GET["answer"];
  if ($ans == 1)
    echo "Офицерский состав";
  else if ($ans == 2)
    echo "Операционная система";
  else
    echo "Большой полосатый мух";
?>
```

Мы используем дополнительную переменную `$ans` для удобства, потому что так короче.

Второй способ — это использовать массив. Давайте заранее запишем в массив, какому номеру соответствует какой вариант ответа, а потом просто обратимся к нужному элементу массива. Нам поможет следующий код:
```php
<?
  $list[1] = "Офицерский состав";
  $list[2] = "Операционная система";
  $list[3] = "Большой полосатый мух";

  $ans = $_GET["answer"];
  echo $list[$ans];
?>
```

Массивы, как и обычные переменные, не требуется объявлять. Мы заполнили массив `$list` и при выводе ответа обратились к элементу этого массива с индексом `$ans`.

Отметим, что в скрипте start.php мы просто выводили текст на странице и даже не использовали HTML-теги. Это было сделано для упрощения, а лучше было еще написать стандартные теги `<html>`, `<head>` и `<body>`.

Ну что, подготовка к написанию более серьезного скрипта закончилась, начинаем писать полноценный тестер с работой с файлами.

Итак, в файле test.txt будут храниться вопросы теста, а в файл stat.txt мы будем сохранять статистику тестирования пользователей.

Для хранения вопросов теста мы будем использовать следующий формат. В одной строке будет записан вопрос. Дальше следуют несколько строк с вариантами ответов. В правильном варианте ответа первый символ — пробел, в остальных вариантах ответа первый символ — не пробел. Дальше следует пустая строка и следующий вопрос. В вопросе и вариантах ответах могут встречаться HTML-теги, поэтому текст можно делать жирным, курсивным, а также можно вставлять таблицы и картинки.

Например, файл test.txt может выглядеть следующим образом:

```
Сколько получится, если полтину разделить на половину?
полтина
четвертина
 рубль

Сколько точек пересечения у графиков функций <i>y</i> = sin <i>x</i> и <i>y</i> = arcsin <i>x</i>?
0
 1
2
3

Какого алгоритма сортировки пока ещё не придумали?
вставками
выбором
пузырьком
 приседаниями
```

Обратите внимание, что каждый вопрос и каждый ответ должен быть записан в одну строку, а между разными вопросами обязательно должна быть пустая строка.

Наша первая задача — считать тесты из файла test.txt и вывести в виде формы, как в нашем первом примере.

Вообще мы сделаем 3 скрипта: index.php, check.php и stat.php. На странице index.php будет открываться сам тест. При нажатии на кнопку «Отправить» будет открываться страница check.php, и на ней будут отображаться результаты тестирования. А на странице stat.php будет показываться статистика тестирования.

Заметим сразу, что считывать тесты из файла test.txt нам нужно будет как в скрипте index.php, так и в скрипте check.php. Поэтому, чтобы избежать повторяющегося кода, мы создадим еще один скрипт read.php, который будет считывать тесты из файла в массив. Его мы включим в оба скрипта index.php и check.php.

Давайте напишем в файле index.php следующий код:
```php
<?
  include("read.php");
?>
```

В этом случае содержимое скрипта read.php будет автоматически включено в скрипт index.php, как будто оно там и было.

Теперь займемся реализацией скрипта read.php. Этот скрипт должен считать тесты из файла test.txt и занести информацию в массивы. Опишем эти массивы.

Переменная `$tests_num` будет содержать количество тестов. Массив `$questions` будет содержать вопросы тестов. Массив `$answers_num` будет содержать количество вариантов ответа для каждого вопроса. Двумерный массив `$answers` будет содержать варианты ответа. Массив `$correct_answer` будет содержать номер правильного ответа для каждого вопроса.

Пришла пора познакомиться с функциями PHP для работы с файлами. Они аналогичны функциям C++.

Прежде чем считывать из файла или записывать в файл, необходимо открыть файл. Для этого предназначена функция `fopen`.

Открытие файла test.txt для чтения:
```php
$file = fopen("test.txt", "r");
```

Открытие файла stat.txt для записи с очисткой предыдущего содержимого файла:
```php
$file = fopen("stat.txt", "w");
```

Открытие файла stat.txt для записи в конец файла:
```php
$file = fopen("stat.txt", "a");
```

Таким образом, функция `fopen` принимает на вход 2 аргумента: имя открываемого файла и режим работы с файлом (чтение, запись с очисткой либо запись в конец файла). Функция возвращает дескриптор файла, который должен быть присвоен какой-нибудь переменной, которая может иметь любое имя. Теперь при чтении или записи в файл нужно указывать файловую переменную `$file`.

После выполнения всех операций над файлом его необходимо закрыть. Для этого есть функция `fclose`. Например,
```php
fclose($file);
```

Если файл открыт для чтения, то прочитать строку из этого файла можно при помощи функции `fgets`:
```php
$str = fgets($file, 100);
```

Первый аргумент функции `fgets` — это файловая переменная, второй аргумент — это максимальное количество байт, которое будет считано, плюс 1. Чтение прекращается, если достигнут конец строки или конец файла. Функция возвращает прочитанную строку. Но если нужно считать число, то в скрипте эту строку можно использовать как число, например, в арифметических операциях, так как в PHP нет строгой типизации переменных.

Если файл открыт для записи, то записать строку в файл можно при помощи функции `fputs`:
```php
fputs($file, "Моя бабушка пишет на C код");
```

Подробнее про работу с файлами в PHP вы можете прочитать здесь: http://www.softtime.ru/bookphp/gl6_1.php.

Нам также понадобятся циклы — конструкции языка программирования, которые используются для программирования повторяющихся действий. Циклы в PHP аналогичны циклам в C++.

Цикл с предусловием:
```php
while (условие) {
  операторы
}
```

`условие` — это логическое условие, `операторы` — это последовательность любых операторов, среди которых могут быть и другие циклы. Если в цикле только один оператор, то фигурные скобки можно опустить. Пример:
```php
$x = 10;
while ($x > 0) {
  echo $x;
  echo "<br>";
  $x--;
}
```

Данный скрипт выводит все числа от 1 до 10 в убывающем порядке. Вначале переменной `$x` присваивается значение 10. Потом проверятся условие цикла. Если оно не выполнено, то выполнение цикла прекращается. Если условие выполнено, то выполняется тело цикла и все повторяется снова, то есть проверяется условие цикла и т.д.

Цикл с постусловием:
```php
do {
  операторы
} while (условие);
```

Вначале выполняются операторы, затем проверяется условие. Этот цикл отличается от предыдущего тем, что в данном случае операторы обязательно будут выполнены хотя бы один раз.

Арифметический цикл:

```php
for (выражение1; выражение2; выражение3) {
  операторы
}
```

`выражение1` — это выражение инициализации, которое выполняется в самом начале, перед выполнением цикла. `выражение2` аналогично условию в двух предыдущих циклах: пока `выражение2` возвращает логическое значение `true` (истина), выполняются `операторы` (тело цикла). `выражение3` вычисляется после каждого выполнения тела цикла.

Выведем числа от 1 до 10 в возрастающем порядке.

```php
for ($i = 1; $i <= 10; $i++) {
  echo $i;
  echo "<br>";
}
```

Операция `$x++` (инкремент) увеличивает значение переменной `$x` на 1 и возвращает старое значение переменной. Аналогично, операция `$x--` (декремент) уменьшает значение переменной `$x` на 1.

Давайте приступим к реализации чтения тестов из файла test.txt и записи информации в массивы. Не забудьте создать файл test.txt и заполнить его информацией, например, так, как показано выше. Писать код для чтения тестов мы будем в файле read.php. PHP-код в файле read.php должен располагаться между тегами `<? … ?>`

Вот такой вот код:

```php
<?
  $file = fopen("test.txt", "r");
  $tests_num = 0;
  while (!feof($file)) {
    $tests_num++;
    $questions[$tests_num] = trim(fgets($file, 4096));
    $answers_num[$tests_num] = 0;
    while (true) {
      $s = fgets($file, 4096);
      if (trim($s) == "")
        break;
      $answers_num[$tests_num]++;
      $answers[$tests_num][$answers_num[$tests_num]] = trim($s);
      if ($s[0] == " ")
        $correct_answer[$tests_num] = $answers_num[$tests_num];
    }
  }
  fclose($file);
?>
```

Вначале мы открываем файл test.txt для чтения, файловая переменная `$file`. Затем инициализируем переменную `$tests_num`. Все переменные рекомендуется всегда инициализировать, то есть нельзя использовать значение переменной, которой не было присвоено никакое значение. Дальше идет цикл `while` с условием `!feof($file)`. Функция `feof` проверяет, достигнут ли конец файла. Восклицательный знак означает логическое отрицание. Поэтому этот цикл будет выполняться, пока не достигнут конец файла.

Дальше к значению переменной `$tests_num` прибавляется 1. Потом при помощи функции `fgets` из файла считывается строка длиной не более 4095 символов, и к строке, который вернула функция `fgets`, применяется функция `trim`. Функция `trim` удаляет пробельные символы с начала и с конца строки. Кстати, функция `fgets` возвращает строку вместе с переводом строки, поэтому не лишним будет убрать этот перевод строки.

Дальше мы инициализируем элемент массива `$answers_num` с индексом `$tests_num`, т.е. обозначаем, что пока мы считали 0 вариантов ответов. Затем идет цикл `while (true)`. Это бесконечный цикл, потому что условие цикла всегда истинно. Как тогда завершить выполнение такого цикла? При помощи команды `break`.

Внутри бесконечного цикла мы считываем строку с вариантом ответа в переменную `$s`. Дальше проверяем: если это пустая строка, то выходим из цикла при помощи break. Если мы не вышли из цикла, то продолжаем выполнять тело цикла: прибавляем 1 к `$answers_num[$tests_num]`, что означает, что мы добавляем новый вариант ответа. Дальше присваиваем вариант ответа элементу массива `$answers` с индексами `$tests_num` и `$answers_num[$tests_num]`. Массив `$answers` двумерный — это как бы массив массивов, поэтому у него 2 индекса. Один индекс — это номер теста, а другой — это номер варианта ответа. Мы удалили крайние пробелы из ответа, чтобы они не выводились на веб-странице: так пробел сразу подскажет пользователю правильный ответ.

Дальше проверяем: если в считанной строке первый символ — пробел, то присваиваем элементу массива `$correct_answers` с индексом `$tests_num` значение номера текущего варианта ответа.

В самом конце закрываем файл при помощи `fclose`.

Готово. Теперь в наших массивах записаны тесты, считанные из файла.

Приступаем к написанию скрипта index.php, который должен вывести форму с тестами.

Напомним, что в файле index.php мы уже написали следующий код:
```php
<?
  include("read.php");
?>
```

Обратите внимание, что использование массивов в скрипте index.php должно идти после команды `include`. Иначе значения элементов массивов будут использоваться еще до того, как тесты были считаны из файла.

После предыдущих 3-х строк напишем следующее.
```html
<html>
<head>
<title>Тестирование</title>
</head>
<body>
<form action="check.php" method="post">
<?
  for ($i = 1; $i <= $tests_num; $i++) {
    echo "<p>$i. ".$questions[$i]."</p>\n";
    for ($j = 1; $j <= $answers_num[$i]; ++$j) {
      echo "<input type=\"radio\" name=\"A$i\" value=\"$j\"";
      if ($j == 1)
        echo " checked";
      echo "/>";
      echo $answers[$i][$j]."<br>\n";
    }
  }
?>
<p>Ваше имя: <input type="text" name="username" size="40"/></p>
<p><input type="submit" value="Отправить"/></p>
</form>
</body>
</html>
```

Здесь в цикле выводятся тесты. Разберем строку
```php
echo "<p>$i. ".$questions[$i]."</p>\n";
```

Во-первых, внутри строки `"<p>$i. "` стоит переменная `$i`. Так вот, если использовать двойные кавычки, то вместо `$i` будет выведено значение этой переменной, а если одинарные кавычки, то так и будет выведено `$i`.

Во-вторых, между строками `"<p>$i. " и $questions[$i]` стоит точка. Это операция конкатенации (сцепления) строк. К этим двум строкам аналогично прицепляется строка `"</p>\n"`.

Дальше выводится тег `<input>`. Он выводится по частям. Вначале выводится его часть без последних двух символов `/>`. А потом проверяем: если `$j == 1`, то выводим `checked`, иначе не выводим. Затем выводятся символы `/>`.

Обратите внимание на сочетание символов `\"` внутри строки. Дело в том, что если внутри строки, обрамленной двойными кавычками, вставить двойные кавычки, то они будут восприниматься как конец строки. Поэтому перед кавычкой нужно поставить обратный слеш. `\"` — это специальная служебная последовательность. Точно так же `\n` означает перевод строки.

В данном примере мы проверяем: если текущий вариант ответа — это первый вариант ответа, то он помечается, как выбранный. Это делается для того, чтобы избежать лишних проверок, выбрал ли пользователь хоть какой-нибудь вариант ответа.

Хотя это может быть вашим дополнительным заданием. Проверку можно сделать и на JavaScript (до отправки запроса на сервер), и дополнительно на PHP (проверка запроса, отправленного на сервер). В случае, если какой-то вариант не выбран, можно выводить сообщение об ошибке. Можно пойти и по другому пути. Можно не делать такую проверку, а просто никак не засчитывать ответы на вопросы, на которые не был дан ответ.

Теперь откройте наш сайт test1.ru. Вот что должно получиться.

![Рис. 2](/images/php/files/php_fig2.png)


Теперь обязательно откройте в браузере исходный код страницы, который был сгенерирован PHP-скриптом, и проанализируйте его.

Приступаем к написанию скрипта check.php, который будет проверять ответы пользователя. Начинаться он будет так же, как и index.php:
```php
<?
  include("read.php");
?>
```

Как мы уже говорили, это связано с тем, что скрипт check.php тоже должен считать тесты из файла test.txt и записать их в массив.

Напишем в файле check.php после этих 3-х строк следующий код:
```php
<html>
<head>
  <title>Результаты тестирования</title>
</head>
<body>
<?
  $result = "";
  $correct = 0; $incorrect = 0;
  for ($i = 1; $i <= $tests_num; $i++) {
    $user_answer = $_POST["A$i"];
    if ($user_answer == $correct_answer[$i]) {
      $result = $result."+";
      $correct++;
    }
    else {
      $result = $result."-";
      $incorrect++;
    }
  }
  $score = $correct/$tests_num*100;

  echo "<p>Имя: ".$_POST["username"]."</p>\n";
  echo "<p>Результат тестирования: $result</p>\n";
  echo "<p>Правильных ответов: $correct</p>\n";
  echo "<p>Неправильных ответов: $incorrect</p>\n";
  echo "<p>Результат: ".$score." %</p>\n";

  $file = fopen("stat.txt", "a");
  fputs($file, $_POST["username"]."\n");
  fputs($file, $score."\n");
  fclose($file);
?>

<p><a href="stat.php">Статистика тестирования</a></p>
<p><a href="index.php">Главная страница</a></p>

</body>
</html>
```

Теперь после нажатия на кнопку «Отправить» откроется вот такая страница:
![Рис. 3](/images/php/files/php_fig3.png)

Имена параметров у нас имеют вид A\*, где вместо \* номер теста. Так как в форме использовался метод POST, то для обращения к параметрам формы используем массив `$_POST`.

В цикле подсчитывается количество правильных и неправильных ответов, затем вычисляется процент правильных ответов. Также в цикле формируется строка из плюсов и минусов (плюс — правильный ответ, минус — неправильный ответ).

Статистика записывается в файл stat.txt. Файл открывается для записи в конец файла, выводим имя пользователя и результат в процентах.

Осталось реализовать скрипт stat.php, который покажет статистику тестирования. Этот скрипт должен считать статистику из файла stat.txt в массив и вывести ее.

Напишем такой скрипт:
```php
<html>
<head>
  <title>Статистика тестирования</title>
</head>
<body>
<?
  $file = fopen("stat.txt", "r");
  $users_num = 0;
  while (!feof($file)) {
    $users_num++;
    $names[$users_num] = fgets($file, 4096);
    $scores[$users_num] = (float)fgets($file, 4096);
  }
  fclose($file);

  echo "<table>";
  for ($i = 1; $i <= $users_num; $i++) {
    echo "<tr>\n";
    echo "<td>".$names[$i]."</td>\n";
    echo "<td>".$scores[$i]."</td>\n";
    echo "</tr>\n";
  }
  echo "</table>\n";
?>

<p><a href="index.php">Главная страница</a></p>

</body>
</html>
```

Открываем файл stat.txt для чтения, заполняем массивы `$names` (имена пользователей) и `$scores` (их результаты). `$users_num` — это количество пользователей. `(float)` означает преобразование типа от строкового к числовому.

Получим такую страницу:

![Рис. 4](/images/php/files/php_fig4.png)

Остался последний штрих. Давайте отсортируем все записи по убыванию результатов.

Вначале напомним, как поменять местами значения 2-х переменных. Делается это при помощи третьей переменной. Код, который меняет значения переменных `$a` и `$b`:
```php
$tmp = $a;
$a = $b;
$b = $tmp;
```

Если нам нужно отсортировать числовой массив $a по убыванию, то вот как можно это сделать:
```php
for ($i = 1; $i <= $n; $i++) {
  for ($j = $i+1; $j <= $n; $j++) {
    if ($a[$i] < $a[$j]) {
      $tmp = $a[$i];
      $a[$i] = $a[$j];
      $a[$j] = $tmp;
    }
  }
}
```

Это сортировка простым выбором.

В качестве дополнительного задания можете изменить в коде один символ таким образом, чтобы сортировка была не по убыванию, а по возрастанию.

Нам же нужно отсортировать по убыванию сразу два массива, но по значениям одного массива (массива результатов). Попробуйте сделать это самостоятельно.

Полную версию исходников, а также сам этот сайт вы можете найти здесь: http://vlprog.besaba.com/stud. Удачи!


---


Собственно говоря, *ваше первое задание* — реализовать все эти скрипты и разобраться, как они работают.

*Задание.* Реализуйте проверку, чтобы в каждом задании был ровно один вариант ответа. Если это условие не выполняется, должно выводиться сообщение об ошибке красными буквами.

*Задание.* Измените скрипт таким образом, чтобы в каждом вопросе могло быть любое количество вариантов ответа и вместо круглых кнопок для выбора ответа выводились галочки.

*Задание.* Сделайте так, чтобы при выводе статистики тестирования результаты тестирования пользователя с одним и тем же именем выводились на одной строке.

*Дополнительное задание для самостоятельной работы.* Оно легче, чем реализация тестирования. Напишите две веб-страницы на PHP. На одной странице расположите форму с однострочным текстовым полем ввода и кнопкой «Отправить». При нажатии на кнопку введенный текст должен отправляться на сервер (так сказать, на вторую страницу) и сохраняться в файл. На второй странице должны выводиться все отправленные сообщения. Два варианта:

а) в том порядке, в котором они были отправлены;

б) в противоположном порядке.

Как вы уже догадались, в случае а) достаточно считывать сообщения по одному и тут же выводить (можно даже разными цветами), а в случае б) необходимо сначала считать все сообщения и записать их в массив, а потом уже вывести в обратном порядке. Ну, или для любителей рекурсии можно применить рекурсию, для этого вам нужно применить рекурсию, а для этого нужно применить рекурсию, а для этого…

Просто вывести содержимое файла на страницу можно при помощи функции PHP `readfile` (см. http://softtime.ru/bookphp/gl6_2.php), но чтобы было красивее, можно считывать каждую строку по отдельности и выводить на экран в виде таблицы или в виде маркированного списка (тег `<ul>`).


### Дополнительные материалы

Отличный учебник по PHP: http://softtime.ru/bookphp

Онлайновые уроки по PHP: http://www.codecademy.com/ru/tracks/php

Видеоуроки по PHP: http://vk.com/wall-49053453_7563
